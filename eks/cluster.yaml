AWSTemplateFormatVersion: "2010-09-09"

Description: A EKS Cluster.

Parameters:
  ### Stack
  # Stack configuraiton
  ProjectName:
    Type: String
    Description: "[REQUIRED] The name of this project."
  CustomResourcesProviderStackName:
    Type: String
    Description: "[REQUIRED] The name of EKS CloudFormaiton custom resources provider stack name."

  ### Cluster
  # Cluster configuration - general
  ClusterName:
    Type: String
    Description: "[REQUIRED] The name of EKS cluster."
  IpFamily:
    Type: String
    Description: "[REQUIRED] The type of EKS cluster's IP family."
    AllowedValues:
      - ipv4
      - ipv6
    Default: ipv4
  SecretKmsKeyArn:
    Type: String
    Description: "[optional] The arn of KMS key to encrypt kubernetes secrets."
    Default: ""
  ClusterRoleName:
    Type: String
    Description: "[REQUIRED] The name of EKS cluster's IAM Role."
  ClusterVersion:
    Type: String
    Description: "[REQUIRED] The version of EKS cluster."
    AllowedValues:
      - "1.21"
      - "1.22"
      - "1.23"
      - "1.24"
    Default: "1.24"

  # Cluster configuration - network
  AdditionalSecurityGroupName:
    Type: String
    Description: "[REQUIRED] The name of EKS cluster's additional Security Group."
  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: "[REQUIRED] The id of EKS cluster's VPC."
  SubnetIds:
    Type: List<AWS::EC2::Subnet::Id>
    Description: "[REQUIRED] The id of EKS cluster's Subnets."
  BastionRoleArn:
    Type: String
    Description: "[optional] The arn of bastion instance's IAM Role."
    Default: ""

  ### Node
  # Node configuration - general
  NodeType:
    Type: String
    Description: "[REQUIRED] The node type of EKS cluster's base node."
    AllowedValues:
      - Nodegroup
      - Fargate
    Default: Nodegroup
  NodeRoleName:
    Type: String
    Description: "[REQUIRED] The name of EKS cluster base node's IAM Role."

  # Node configuration - nodegroup
  AmiType:
    Type: String
    Description: "[REQUIRED] The ami type for node group's EC2 instances."
    AllowedValues:
      - AL2_ARM_64
      - AL2_x86_64
      - AL2_x86_64_GPU
      - BOTTLEROCKET_ARM_64
      - BOTTLEROCKET_ARM_64_NVIDIA
      - BOTTLEROCKET_x86_64
      - BOTTLEROCKET_x86_64_NVIDIA
      - CUSTOM
      - WINDOWS_CORE_2019_x86_64
      - WINDOWS_CORE_2022_x86_64
      - WINDOWS_FULL_2019_x86_64
      - WINDOWS_FULL_2022_x86_64
  CapacityType:
    Type: String
    Description: "[optional] The capacity type of node group."
    AllowedValues:
      - ON_DEMAND
      - SPOT
    Default: ON_DEMAND
  DiskSize:
    Type: Number
    Description: "[optional] The size of node gruop's disk."
    Default: "20"
  InstanceTypes:
    Type: List<String>
    Description: "[REQUIRED] The types for node group's EC2 instances."
    Default: "t3.medium"
  NodegroupName:
    Type: String
    Description: "[REQUIRED] The name of EKS cluster's node group."
  ScalingDesiredSize:
    Type: Number
    Description: "[REQUIRED] The desired size of EKS cluster node group's scaling."
  ScalingMaxSize:
    Type: Number
    Description: "[REQUIRED] The max size of EKS cluster node group's scaling."
  ScalingMinSize:
    Type: Number
    Description: "[REQUIRED] The min size of EKS cluster node group's scaling."

  # Node configuration - fargate
  FargateProfileName:
    Type: String
    Description: "[REQUIRED] The name of EKS cluster's fargate profile."
  SelectorNamespace:
    Type: String
    Description: "[REQUIRED] The namespace of EKS cluster fargate profile's selector. (YOU CAN ADD MORE NAMESPACE AND LABELS IN YAML FILE)"

  ### Addons
  # vpc-cni
  VpcCniRoleName:
    Type: String
    Description: "[optional] The name of vpc-cni's IAM Role."
    Default: ""

  ### Kubernetes resources
  # AWS Load Balance Controller
  EnableLoadBalancerController:
    Type: String
    Description: "[optional] Enable or disable EKS cluster's AWS Load Balancer Controller."
    AllowedValues:
      - "true"
      - "false"
    Default: "false"
  LoadBalancerControllerRoleName:
    Type: String
    Description: "[optional] The name of AWS Load Balancer Controller's IAM Role."
    Default: ""

  # External DNS
  EnableExternalDns:
    Type: String
    Description: "[optional] Enable or disable EKS cluster's External DNS."
    AllowedValues:
      - "true"
      - "false"
    Default: "false"
  ExternalDnsRoleName:
    Type: String
    Description: "[optional] The name of External DNS's IAM Role."
    Default: ""

  # Horizontal Pod Autoscaler
  EnableHorizontalPodAutoscaler:
    Type: String
    Description: "[optional] Enable or disable EKS cluster's Horizontal Pod Autoscaler."
    AllowedValues:
      - "true"
      - "false"
    Default: "false"

  # Cluster Autoscaler
  EnableClusterAutoscaler:
    Type: String
    Description: "[optional] Enable or disable EKS cluster's Cluster Autoscaler."
    AllowedValues:
      - "true"
      - "false"
    Default: "false"
  ClusterAutoscalerRoleName:
    Type: String
    Description: "[optional] The name of Cluster Autoscaler's IAM Role."
    Default: ""

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Stack Configuration
        Parameters:
          - ProjectName
          - CustomResourcesProviderStackName

      - Label:
          default: Cluster Configuration - General
        Parameters:
          - ClusterName
          - IpFamily
          - SecretKmsKeyArn
          - ClusterRoleName
          - ClusterVersion

      - Label:
          default: Cluster Configuration - Network
        Parameters:
          - AdditionalSecurityGroupName
          - VpcId
          - SubnetIds
          - BastionRoleArn

      - Label:
          default: Cluster Configuration - Addons
        Parameters:
          - VpcCniRoleName

      - Label:
          default: Node Configuration - General
        Parameters:
          - NodeType
          - NodeRoleName

      - Label:
          default: Node Configuration - Nodegroup (YOU CAN ADD MORE OPTIONS IN YAML FILE)
        Parameters:
          - AmiType
          - CapacityType
          - DiskSize
          - InstanceTypes
          - NodegroupName
          - ScalingDesiredSize
          - ScalingMinSize
          - ScalingMaxSize

      - Label:
          default: Node Configuration - Fargate (YOU CAN ADD MORE OPTIONS IN YAML FILE)
        Parameters:
          - FargateProfileName
          - SelectorNamespace

      - Label:
          default: Kubernetes Configuration - AWS Load Balancer Controller
        Parameters:
          - EnableLoadBalancerController
          - LoadBalancerControllerRoleName

      - Label:
          default: Kubernetes Configuration - External DNS
        Parameters:
          - EnableExternalDns
          - ExternalDnsRoleName

      - Label:
          default: Kubernetes Configuration - Horizontal Pod Autoscaler
        Parameters:
          - EnableHorizontalPodAutoscaler

      - Label:
          default: Kubernetes Configuration - Cluster Autoscaler
        Parameters:
          - EnableClusterAutoscaler
          - ClusterAutoscalerRoleName

Conditions:
  UseIpv6: !Equals [!Ref IpFamily, "ipv6"]
  UseKms: !Not [!Equals [!Ref SecretKmsKeyArn, ""]]
  UseBastionRole: !Not [!Equals [!Ref BastionRoleArn, ""]]
  UseVpcCniRoleName: !Not [!Equals [!Ref VpcCniRoleName, ""]]

  UseNodegroup: !Equals [!Ref NodeType, "Nodegroup"]
  UseFargate: !Equals [!Ref NodeType, "Fargate"]

  IsEnableLoadBalancerController:
    !Equals [!Ref EnableLoadBalancerController, "true"]

  IsEnableExternalDns: !Equals [!Ref EnableExternalDns, "true"]

  IsEnableHorizontalPodAutoscaler:
    !Equals [!Ref EnableHorizontalPodAutoscaler, "true"]

  IsEnableClusterAutoscaler: !Equals [!Ref EnableClusterAutoscaler, "true"]

Mappings:
  ClusterAutoscalerImageVersionMap:
    "1.21":
      latest: "1.21.2"
    "1.22":
      latest: "1.22.2"
    "1.23":
      latest: "1.23.0"
    "1.24":
      latest: "1.24.0"

Resources:
  ### Get templates from Github to S3
  TemplatesS3Bucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName:
        !Join [
          "-",
          [
            "eks-templates",
            !Select [
              4,
              !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId]]],
            ],
          ],
        ]
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - BucketKeyEnabled: true
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: project
          Value: !Ref ProjectName

  TemplatesFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AmazonS3FullAccess

  TemplatesFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt TemplatesFunctionRole.Arn
      Timeout: 10
      Environment:
        Variables:
          TEMPLATE_BUCKET_NAME: !Ref TemplatesS3Bucket
      EphemeralStorage:
        Size: 1024
      Code:
        ZipFile: |
          from __future__ import print_function
          import urllib3
          import json
          import boto3
          import traceback
          import os

          SUCCESS = "SUCCESS"
          FAILED = "FAILED"

          http = urllib3.PoolManager()

          def send(event, context, responseStatus, responseData, physicalResourceId=None, noEcho=False, reason=None):
              responseUrl = event['ResponseURL']

              print(responseUrl)

              responseBody = {
                  'Status' : responseStatus,
                  'Reason' : reason or "See the details in CloudWatch Log Stream: {}".format(context.log_stream_name),
                  'PhysicalResourceId' : physicalResourceId or context.log_stream_name,
                  'StackId' : event['StackId'],
                  'RequestId' : event['RequestId'],
                  'LogicalResourceId' : event['LogicalResourceId'],
                  'NoEcho' : noEcho,
                  'Data' : responseData
              }

              json_responseBody = json.dumps(responseBody)

              print("Response body:")
              print(json_responseBody)

              headers = {
                  'content-type' : '',
                  'content-length' : str(len(json_responseBody))
              }

              try:
                  response = http.request('PUT', responseUrl, headers=headers, body=json_responseBody)
                  print("Status code:", response.status)


              except Exception as e:

                  print("send(..) failed executing http.request(..):", e)

          def get_data(url):
              req = http.request('GET', url)
              data = req.data
              
              if req.status == 200:
                  return data
              
              else:
                  return None

          def lambda_handler(event, context):
              print(event)

              try:
                  client = boto3.client('s3')
                  s3 = boto3.resource('s3')
                  bucket = s3.Bucket(os.getenv('TEMPLATE_BUCKET_NAME'))

                  if event['RequestType'] == 'Delete':
                    bucket.objects.all().delete()
                    send(event, context, SUCCESS, {}, None)
                  
                  else:
                      urls = [
                          'https://raw.githubusercontent.com/marcus16-kang/cloudformation-templates/main/eks/addons.yaml',
                          'https://raw.githubusercontent.com/marcus16-kang/cloudformation-templates/main/eks/aws-load-balancer-controller.yaml',
                          'https://raw.githubusercontent.com/marcus16-kang/cloudformation-templates/main/eks/cluster-autoscaler.yaml',
                          'https://raw.githubusercontent.com/marcus16-kang/cloudformation-templates/main/eks/external-dns.yaml',
                          'https://raw.githubusercontent.com/marcus16-kang/cloudformation-templates/main/eks/horizontal-pod-autoscaler.yaml',
                          'https://raw.githubusercontent.com/marcus16-kang/cloudformation-templates/main/eks/service-account-role-config.yaml'
                      ]
                      
                      for url in urls:
                          client.put_object(
                              Body=get_data(url),
                              Bucket=os.getenv('TEMPLATE_BUCKET_NAME'),
                              Key=f'eks/{os.path.basename(url)}'
                          )
                      
                      send(event, context, SUCCESS, {}, None)
                    
              except Exception as e:
                  print(str(e))
                  traceback.print_exc()
                  send(event, context, FAILED, {}, None)

  TemplatesFunctionExecution:
    Type: Custom::GetTemplates
    Properties:
      ServiceToken: !GetAtt TemplatesFunction.Arn

  ### EKS cluster's additional Security Group
  AdditionalSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Ref AdditionalSecurityGroupName
      GroupName: !Ref AdditionalSecurityGroupName
      Tags:
        - Key: Name
          Value: !Ref AdditionalSecurityGroupName
        - Key: project
          Value: !Ref ProjectName
      VpcId: !Ref VpcId

  AdditionalSecurityGroupIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      GroupId: !GetAtt AdditionalSecurityGroup.GroupId
      SourceSecurityGroupId: !GetAtt AdditionalSecurityGroup.GroupId

  ### Kubernetes Service Account IAM Role config stack
  ServiceAccountConfig:
    Type: AWS::CloudFormation::Stack
    Properties:
      TemplateURL: !Sub
        - "https://${domain_name}/eks/service-account-role-config.yaml"
        - domain_name: !GetAtt TemplatesS3Bucket.DomainName
      Tags:
        - Key: project
          Value: !Ref ProjectName

  ### EKS cluster
  ClusterRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - eks.amazonaws.com
            Action:
              - "sts:AssumeRole"
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonEKSClusterPolicy
      RoleName: !Ref ClusterRoleName
      Tags:
        - Key: Name
          Value: !Ref ClusterRoleName
        - Key: project
          Value: !Ref ProjectName

  Cluster:
    Type: AWSQS::EKS::Cluster
    Properties:
      EncryptionConfig: !If
        - UseKms
        - - Provider:
              KeyArn: !Ref SecretKmsKeyArn
            Resources:
              - secrets
        - !Ref AWS::NoValue
      EnabledClusterLoggingTypes:
        - api
        - audit
        - authenticator
        - controllerManager
        - scheduler
      Name: !Ref ClusterName
      ResourcesVpcConfig:
        EndpointPrivateAccess: true
        EndpointPublicAccess: false
        SecurityGroupIds:
          - !GetAtt AdditionalSecurityGroup.GroupId
        SubnetIds: !Ref SubnetIds
      RoleArn: !GetAtt ClusterRole.Arn
      KubernetesApiAccess:
        Users:
          - Arn: !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:root"
            Username: "root"
            Groups: ["system:masters"]
        Roles:
          - Arn:
              Fn::ImportValue: !Sub "${CustomResourcesProviderStackName}-KubernetesResourceExecutionRoleArn"
            Username: "CloudFormationKubernetesResourceRole"
            Groups: ["system:masters"]
          - Arn:
              Fn::ImportValue: !Sub "${CustomResourcesProviderStackName}-HelmResourceExecutionRoleArn"
            Username: "CloudFormationHelmResourceRole"
            Groups: ["system:masters"]
          # - !If
          #   - UseBastionRole
          #   - Arn: !Ref BastionRoleArn
          #     Username: "BastionRole"
          #     Groups: ["system:masters"]
          #   - !Ref AWS::NoValue
      Tags:
        - Key: Name
          Value: !Ref ClusterName
        - Key: project
          Value: !Ref ProjectName
      Version: !Ref ClusterVersion

  OidcProvider:
    Type: AWS::IAM::OIDCProvider
    Properties:
      ClientIdList:
        - "sts.amazonaws.com"
      ThumbprintList:
        - "9E99A48A9960B14926BB7F3B02E22DA2B0AB7280"
      Url: !GetAtt Cluster.OIDCIssuerURL
      Tags:
        - Key: project
          Value: !Ref ProjectName

  ### Kubernetes addons for EKS cluster
  Addons:
    Type: AWS::CloudFormation::Stack
    Properties:
      TemplateURL: !Sub
        - "https://${domain_name}/eks/addons.yaml"
        - domain_name: !GetAtt TemplatesS3Bucket.DomainName
      Parameters:
        ClusterName: !Ref Cluster
        ClusterOidcProvider: !Ref OidcProvider
        ClusterOidcIssuerUrl: !GetAtt Cluster.OIDCIssuerURL
        VpcCniRoleName: !Ref VpcCniRoleName
        ServiceAccountRoleConfigArn: !GetAtt ServiceAccountConfig.Outputs.ServiceAccountRoleConfigArn
        ProjectName: !Ref ProjectName
      Tags:
        - Key: project
          Value: !Ref ProjectName

  ### Node - Nodegroup
  NodegroupRole:
    Type: AWS::IAM::Role
    Condition: UseNodegroup
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
            Action:
              - "sts:AssumeRole"
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy
        - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly
        - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy
      Policies: !If
        - UseIpv6
        - - PolicyDocument:
              Version: "2012-10-17"
              Statement:
                - Effect: Allow
                  Action:
                    - ec2:AssignIpv6Addresses
                    - ec2:DescribeInstances
                    - ec2:DescribeTags
                    - ec2:DescribeNetworkInterfaces
                    - ec2:DescribeInstanceTypes
                  Resource: "*"
                - Effect: Allow
                  Action:
                    - ec2:CreateTags
                  Resource:
                    - arn:aws:ec2:*:*:network-interface/*
            PolicyName: AmazonEKS_CNI_IPv6_Policy
        - !Ref AWS::NoValue
      RoleName: !Ref NodeRoleName

  NodegroupRoleInstanceProfile:
    Type: "AWS::IAM::InstanceProfile"
    Condition: UseNodegroup
    Properties:
      Path: "/"
      InstanceProfileName: !Ref NodeRoleName
      Roles:
        - !Ref NodegroupRole

  Nodegroup:
    Type: AWS::EKS::Nodegroup
    Condition: UseNodegroup
    DependsOn: NodegroupRoleInstanceProfile
    Properties:
      AmiType: !Ref AmiType
      CapacityType: !Ref CapacityType
      ClusterName: !Ref Cluster
      DiskSize: !Ref DiskSize # please disable when you use launch template
      # ForceUpdateEnabled: true or false # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-eks-nodegroup.html#cfn-eks-nodegroup-forceupdateenabled
      InstanceTypes: !Ref InstanceTypes # please disable when you use launch template
      # Labels: # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-eks-nodegroup.html#cfn-eks-nodegroup-labels
      #   Key1: Value2
      #   Key2: Value2
      # LaunchTemplate: # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-nodegroup-launchtemplatespecification.html
      #   Id:
      #   Name:
      #   Version:
      NodegroupName: !Ref NodegroupName
      NodeRole: !GetAtt NodegroupRole.Arn
      # RemoteAccess: # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-nodegroup-remoteaccess.html
      #   Ec2SshKey:
      #   SourceSecurityGroups:
      #     - ""
      ScalingConfig:
        DesiredSize: !Ref ScalingDesiredSize
        MaxSize: !Ref ScalingMaxSize
        MinSize: !Ref ScalingMinSize
      Subnets: !Ref SubnetIds
      Tags:
        project: !Ref ProjectName
        # key1: value1
        # key2: value2
      # Taints: # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-nodegroup-taint.html
      #   - Effect: NO_EXECUTE | NO_SCHEDULE | PREFER_NO_SCHEDULE
      #     Key: "1" ~ "63"
      #     Value: "0" ~ "63"
      UpdateConfig: # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-nodegroup-updateconfig.html
        MaxUnavailable: 1
        # MaxUnavailablePercentage: "1" ~ "100"

  ### AWS Load Balancer Controller
  AwsLoadBalancerController:
    Type: AWS::CloudFormation::Stack
    Condition: IsEnableLoadBalancerController
    Properties:
      TemplateURL: !Sub
        - "https://${domain_name}/eks/aws-load-balancer-controller.yaml"
        - domain_name: !GetAtt TemplatesS3Bucket.DomainName
      Parameters:
        ClusterName: !Ref Cluster
        ClusterOidcProvider: !Ref OidcProvider
        ClusterOidcIssuerUrl: !GetAtt Cluster.OIDCIssuerURL
        LoadBalancerControllerRoleName: !Ref LoadBalancerControllerRoleName
        ServiceAccountRoleConfigArn: !GetAtt ServiceAccountConfig.Outputs.ServiceAccountRoleConfigArn
        ProjectName: !Ref ProjectName
      Tags:
        - Key: project
          Value: !Ref ProjectName

  ### External DNS
  ExternalDns:
    Type: AWS::CloudFormation::Stack
    Condition: IsEnableExternalDns
    Properties:
      TemplateURL: !Sub
        - "https://${domain_name}/eks/external-dns.yaml"
        - domain_name: !GetAtt TemplatesS3Bucket.DomainName
      Parameters:
        ClusterName: !Ref Cluster
        ClusterOidcProvider: !Ref OidcProvider
        ClusterOidcIssuerUrl: !GetAtt Cluster.OIDCIssuerURL
        ExternalDnsRoleName: !Ref ExternalDnsRoleName
        ServiceAccountRoleConfigArn: !GetAtt ServiceAccountConfig.Outputs.ServiceAccountRoleConfigArn
        ProjectName: !Ref ProjectName
      Tags:
        - Key: project
          Value: !Ref ProjectName

  ### Horizontal Pod Autoscaler
  HorizontalPodAutoscaler:
    Type: AWS::CloudFormation::Stack
    Condition: IsEnableHorizontalPodAutoscaler
    Properties:
      TemplateURL: !Sub
        - "https://${domain_name}/eks/horizontal-pod-autoscaler.yaml"
        - domain_name: !GetAtt TemplatesS3Bucket.DomainName
      Parameters:
        ClusterName: !Ref Cluster
      Tags:
        - Key: project
          Value: !Ref ProjectName
  
  ### Cluster Autoscaler
  ClusterAutoscaler:
    Type: AWS::CloudFormation::Stack
    Condition: IsEnableExternalDns
    Properties:
      TemplateURL: !Sub
        - "https://${domain_name}/eks/clsuter-autoscaler.yaml"
        - domain_name: !GetAtt TemplatesS3Bucket.DomainName
      Parameters:
        ClusterName: !Ref Cluster
        ClusterOidcProvider: !Ref OidcProvider
        ClusterOidcIssuerUrl: !GetAtt Cluster.OIDCIssuerURL
        ClusterAutoscalerRoleName: !Ref ClusterAutoscalerRoleName
        ServiceAccountRoleConfigArn: !GetAtt ServiceAccountConfig.Outputs.ServiceAccountRoleConfigArn
        ProjectName: !Ref ProjectName
      Tags:
        - Key: project
          Value: !Ref ProjectName

  # ### Cluster Autoscaler
  # ClusterAutoscalerRole:
  #   Type: AWS::IAM::Role
  #   Condition: IsEnableClusterAutoscaler
  #   Properties:
  #     AssumeRolePolicyDocument:
  #       Version: "2012-10-17"
  #       Statement:
  #         - Effect: Allow
  #           Principal:
  #             Federated: !Ref OidcProvider
  #           Action:
  #             - "sts:AssumeRoleWithWebIdentity"
  #     Path: /
  #     Policies:
  #       - PolicyName: AmazonEKSClusterAutoscalerPolicy
  #         PolicyDocument:
  #           Version: "2012-10-17"
  #           Statement:
  #             - Sid: VisualEditor0
  #               Effect: Allow
  #               Action:
  #                 - autoscaling:SetDesiredCapacity
  #                 - autoscaling:TerminateInstanceInAutoScalingGroup
  #               Resource: "*"
  #               Condition:
  #                 StringEquals:
  #                   aws:ResourceTag/k8s.io/cluster-autoscaler/my-cluster: owned
  #             - Sid: VisualEditor1
  #               Effect: Allow
  #               Action:
  #                 - autoscaling:DescribeAutoScalingInstances
  #                 - autoscaling:DescribeAutoScalingGroups
  #                 - ec2:DescribeLaunchTemplateVersions
  #                 - autoscaling:DescribeTags
  #                 - autoscaling:DescribeLaunchConfigurations
  #               Resource: "*"
  #     RoleName: !If
  #       - UseClusterAutoscalerRoleName
  #       - !Ref ClusterAutoscalerRoleName
  #       - !Sub "${ClusterName}-cluster-autoscaler-role"
  #     Tags:
  #       - Key: Name
  #         Value: !If
  #           - UseClusterAutoscalerRoleName
  #           - !Ref ClusterAutoscalerRoleName
  #           - !Sub "${ClusterName}-cluster-autoscaler-role"
  #       - Key: project
  #         Value: !Ref ProjectName

  # ClusterAutoscalerRoleConfig:
  #   Type: Custom::ServiceAccountRoleConfig
  #   Condition: IsEnableClusterAutoscaler
  #   Properties:
  #     ServiceToken: !GetAtt ServiceAccountRoleConfigFunction.Arn
  #     RoleName: !Ref ClusterAutoscalerRole
  #     OidcIssuerUrl: !GetAtt Cluster.OIDCIssuerURL
  #     OidcArn: !Ref OidcProvider
  #     Namespace: kube-system
  #     ServiceAccount: cluster-autoscaler

  # ClusterAutoscalerResources:
  #   Type: AWSQS::Kubernetes::Resource
  #   Condition: IsEnableClusterAutoscaler
  #   DependsOn: ClusterAutoscalerRoleConfig
  #   Properties:
  #     ClusterName: !Ref Cluster
  #     Namespace: kube-system
  #     Manifest: !Sub
  #       - |
  #         apiVersion: v1
  #         kind: ServiceAccount
  #         metadata:
  #           labels:
  #             k8s-addon: cluster-autoscaler.addons.k8s.io
  #             k8s-app: cluster-autoscaler
  #           name: cluster-autoscaler
  #           namespace: kube-system
  #         ---
  #         apiVersion: rbac.authorization.k8s.io/v1
  #         kind: ClusterRole
  #         metadata:
  #           name: cluster-autoscaler
  #           labels:
  #             k8s-addon: cluster-autoscaler.addons.k8s.io
  #             k8s-app: cluster-autoscaler
  #         rules:
  #           - apiGroups: [""]
  #             resources: ["events", "endpoints"]
  #             verbs: ["create", "patch"]
  #           - apiGroups: [""]
  #             resources: ["pods/eviction"]
  #             verbs: ["create"]
  #           - apiGroups: [""]
  #             resources: ["pods/status"]
  #             verbs: ["update"]
  #           - apiGroups: [""]
  #             resources: ["endpoints"]
  #             resourceNames: ["cluster-autoscaler"]
  #             verbs: ["get", "update"]
  #           - apiGroups: [""]
  #             resources: ["nodes"]
  #             verbs: ["watch", "list", "get", "update"]
  #           - apiGroups: [""]
  #             resources:
  #               - "namespaces"
  #               - "pods"
  #               - "services"
  #               - "replicationcontrollers"
  #               - "persistentvolumeclaims"
  #               - "persistentvolumes"
  #             verbs: ["watch", "list", "get"]
  #           - apiGroups: ["extensions"]
  #             resources: ["replicasets", "daemonsets"]
  #             verbs: ["watch", "list", "get"]
  #           - apiGroups: ["policy"]
  #             resources: ["poddisruptionbudgets"]
  #             verbs: ["watch", "list"]
  #           - apiGroups: ["apps"]
  #             resources: ["statefulsets", "replicasets", "daemonsets"]
  #             verbs: ["watch", "list", "get"]
  #           - apiGroups: ["storage.k8s.io"]
  #             resources: ["storageclasses", "csinodes", "csidrivers", "csistoragecapacities"]
  #             verbs: ["watch", "list", "get"]
  #           - apiGroups: ["batch", "extensions"]
  #             resources: ["jobs"]
  #             verbs: ["get", "list", "watch", "patch"]
  #           - apiGroups: ["coordination.k8s.io"]
  #             resources: ["leases"]
  #             verbs: ["create"]
  #           - apiGroups: ["coordination.k8s.io"]
  #             resourceNames: ["cluster-autoscaler"]
  #             resources: ["leases"]
  #             verbs: ["get", "update"]
  #         ---
  #         apiVersion: rbac.authorization.k8s.io/v1
  #         kind: Role
  #         metadata:
  #           name: cluster-autoscaler
  #           namespace: kube-system
  #           labels:
  #             k8s-addon: cluster-autoscaler.addons.k8s.io
  #             k8s-app: cluster-autoscaler
  #         rules:
  #           - apiGroups: [""]
  #             resources: ["configmaps"]
  #             verbs: ["create","list","watch"]
  #           - apiGroups: [""]
  #             resources: ["configmaps"]
  #             resourceNames: ["cluster-autoscaler-status", "cluster-autoscaler-priority-expander"]
  #             verbs: ["delete", "get", "update", "watch"]

  #         ---
  #         apiVersion: rbac.authorization.k8s.io/v1
  #         kind: ClusterRoleBinding
  #         metadata:
  #           name: cluster-autoscaler
  #           labels:
  #             k8s-addon: cluster-autoscaler.addons.k8s.io
  #             k8s-app: cluster-autoscaler
  #         roleRef:
  #           apiGroup: rbac.authorization.k8s.io
  #           kind: ClusterRole
  #           name: cluster-autoscaler
  #         subjects:
  #           - kind: ServiceAccount
  #             name: cluster-autoscaler
  #             namespace: kube-system

  #         ---
  #         apiVersion: rbac.authorization.k8s.io/v1
  #         kind: RoleBinding
  #         metadata:
  #           name: cluster-autoscaler
  #           namespace: kube-system
  #           labels:
  #             k8s-addon: cluster-autoscaler.addons.k8s.io
  #             k8s-app: cluster-autoscaler
  #         roleRef:
  #           apiGroup: rbac.authorization.k8s.io
  #           kind: Role
  #           name: cluster-autoscaler
  #         subjects:
  #           - kind: ServiceAccount
  #             name: cluster-autoscaler
  #             namespace: kube-system

  #         ---
  #         apiVersion: apps/v1
  #         kind: Deployment
  #         metadata:
  #           name: cluster-autoscaler
  #           namespace: kube-system
  #           labels:
  #             app: cluster-autoscaler
  #         spec:
  #           replicas: 1
  #           selector:
  #             matchLabels:
  #               app: cluster-autoscaler
  #           template:
  #             metadata:
  #               labels:
  #                 app: cluster-autoscaler
  #               annotations:
  #                 prometheus.io/scrape: 'true'
  #                 prometheus.io/port: '8085'
  #             spec:
  #               priorityClassName: system-cluster-critical
  #               securityContext:
  #                 runAsNonRoot: true
  #                 runAsUser: 65534
  #                 fsGroup: 65534
  #               serviceAccountName: cluster-autoscaler
  #               containers:
  #                 - image: k8s.gcr.io/autoscaling/cluster-autoscaler:v1.23.0
  #                   name: cluster-autoscaler
  #                   resources:
  #                     limits:
  #                       cpu: 100m
  #                       memory: 600Mi
  #                     requests:
  #                       cpu: 100m
  #                       memory: 600Mi
  #                   command:
  #                     - ./cluster-autoscaler
  #                     - --v=4
  #                     - --stderrthreshold=info
  #                     - --cloud-provider=aws
  #                     - --skip-nodes-with-local-storage=false
  #                     - --expander=least-waste
  #                     - --node-group-auto-discovery=asg:tag=k8s.io/cluster-autoscaler/enabled,k8s.io/cluster-autoscaler/${cluster_name}
  #                     - --balance-similar-node-groups
  #                     - --skip-nodes-with-system-pods=false
  #                   volumeMounts:
  #                     - name: ssl-certs
  #                       mountPath: /etc/ssl/certs/ca-certificates.crt #/etc/ssl/certs/ca-bundle.crt for Amazon Linux Worker Nodes
  #                       readOnly: true
  #                   imagePullPolicy: "Always"
  #               volumes:
  #                 - name: ssl-certs
  #                   hostPath:
  #                     path: "/etc/ssl/certs/ca-bundle.crt"
  #       - cluster_name: !Ref Cluster

  # ClusterAutoscalerServiceAccountAnnotationUpdate:
  #   Type: AWSQS::Kubernetes::Resource
  #   Condition: IsEnableClusterAutoscaler
  #   DependsOn: ClusterAutoscalerResources
  #   Properties:
  #     ClusterName: !Ref Cluster
  #     Namespace: kube-system
  #     Manifest: !Sub
  #       - |
  #         apiVersion: v1
  #         kind: ServiceAccount
  #         metadata:
  #           labels:
  #             k8s-addon: cluster-autoscaler.addons.k8s.io
  #             k8s-app: cluster-autoscaler
  #           annotations:
  #             eks.amazonaws.com/role-arn: ${cluster_autoscaler_role}
  #           name: cluster-autoscaler
  #           namespace: kube-system
  #       - cluster_autoscaler_role: !GetAtt ClusterAutoscalerRole.Arn

  # ClusterAutoscalerDeploymentAnnotationUpdate:
  #   Type: AWSQS::Kubernetes::Resource
  #   Condition: IsEnableClusterAutoscaler
  #   DependsOn: ClusterAutoscalerServiceAccountAnnotationUpdate
  #   Properties:
  #     ClusterName: !Ref Cluster
  #     Namespace: kube-system
  #     Manifest: !Sub
  #       - |
  #         apiVersion: apps/v1
  #         kind: Deployment
  #         metadata:
  #           name: cluster-autoscaler
  #           namespace: kube-system
  #           labels:
  #             app: cluster-autoscaler
  #         spec:
  #           replicas: 1
  #           selector:
  #             matchLabels:
  #               app: cluster-autoscaler
  #           template:
  #             metadata:
  #               labels:
  #                 app: cluster-autoscaler
  #               annotations:
  #                 prometheus.io/scrape: 'true'
  #                 prometheus.io/port: '8085'
  #                 cluster-autoscaler.kubernetes.io/safe-to-evict: 'false'
  #             spec:
  #               priorityClassName: system-cluster-critical
  #               securityContext:
  #                 runAsNonRoot: true
  #                 runAsUser: 65534
  #                 fsGroup: 65534
  #               serviceAccountName: cluster-autoscaler
  #               containers:
  #                 - image: k8s.gcr.io/autoscaling/cluster-autoscaler:v1.23.0
  #                   name: cluster-autoscaler
  #                   resources:
  #                     limits:
  #                       cpu: 100m
  #                       memory: 600Mi
  #                     requests:
  #                       cpu: 100m
  #                       memory: 600Mi
  #                   command:
  #                     - ./cluster-autoscaler
  #                     - --v=4
  #                     - --stderrthreshold=info
  #                     - --cloud-provider=aws
  #                     - --skip-nodes-with-local-storage=false
  #                     - --expander=least-waste
  #                     - --node-group-auto-discovery=asg:tag=k8s.io/cluster-autoscaler/enabled,k8s.io/cluster-autoscaler/${cluster_name}
  #                   volumeMounts:
  #                     - name: ssl-certs
  #                       mountPath: /etc/ssl/certs/ca-certificates.crt #/etc/ssl/certs/ca-bundle.crt for Amazon Linux Worker Nodes
  #                       readOnly: true
  #                   imagePullPolicy: "Always"
  #               volumes:
  #                 - name: ssl-certs
  #                   hostPath:
  #                     path: "/etc/ssl/certs/ca-bundle.crt"
  #       - cluster_name: !Ref Cluster

  # ClusterAutoscalerDeploymentContainerUpdate:
  #   Type: AWSQS::Kubernetes::Resource
  #   Condition: IsEnableClusterAutoscaler
  #   DependsOn: ClusterAutoscalerDeploymentAnnotationUpdate
  #   Properties:
  #     ClusterName: !Ref Cluster
  #     Namespace: kube-system
  #     Manifest: !Sub
  #       - |
  #         apiVersion: apps/v1
  #         kind: Deployment
  #         metadata:
  #           name: cluster-autoscaler
  #           namespace: kube-system
  #           labels:
  #             app: cluster-autoscaler
  #         spec:
  #           replicas: 1
  #           selector:
  #             matchLabels:
  #               app: cluster-autoscaler
  #           template:
  #             metadata:
  #               labels:
  #                 app: cluster-autoscaler
  #               annotations:
  #                 prometheus.io/scrape: 'true'
  #                 prometheus.io/port: '8085'
  #                 cluster-autoscaler.kubernetes.io/safe-to-evict: 'false'
  #             spec:
  #               priorityClassName: system-cluster-critical
  #               securityContext:
  #                 runAsNonRoot: true
  #                 runAsUser: 65534
  #                 fsGroup: 65534
  #               serviceAccountName: cluster-autoscaler
  #               containers:
  #                 - image: k8s.gcr.io/autoscaling/cluster-autoscaler:v1.23.0
  #                   name: cluster-autoscaler
  #                   resources:
  #                     limits:
  #                       cpu: 100m
  #                       memory: 600Mi
  #                     requests:
  #                       cpu: 100m
  #                       memory: 600Mi
  #                   command:
  #                     - ./cluster-autoscaler
  #                     - --v=4
  #                     - --stderrthreshold=info
  #                     - --cloud-provider=aws
  #                     - --skip-nodes-with-local-storage=false
  #                     - --expander=least-waste
  #                     - --node-group-auto-discovery=asg:tag=k8s.io/cluster-autoscaler/enabled,k8s.io/cluster-autoscaler/${cluster_name}
  #                     - --balance-similar-node-groups
  #                     - --skip-nodes-with-system-pods=false
  #                   volumeMounts:
  #                     - name: ssl-certs
  #                       mountPath: /etc/ssl/certs/ca-certificates.crt #/etc/ssl/certs/ca-bundle.crt for Amazon Linux Worker Nodes
  #                       readOnly: true
  #                   imagePullPolicy: "Always"
  #               volumes:
  #                 - name: ssl-certs
  #                   hostPath:
  #                     path: "/etc/ssl/certs/ca-bundle.crt"
  #       - cluster_name: !Ref Cluster

  # ClusterAutoscalerDeploymentImageUpdate:
  #   Type: AWSQS::Kubernetes::Resource
  #   Condition: IsEnableClusterAutoscaler
  #   DependsOn: ClusterAutoscalerDeploymentContainerUpdate
  #   Properties:
  #     ClusterName: !Ref Cluster
  #     Namespace: kube-system
  #     Manifest: !Sub
  #       - |
  #         apiVersion: apps/v1
  #         kind: Deployment
  #         metadata:
  #           name: cluster-autoscaler
  #           namespace: kube-system
  #           labels:
  #             app: cluster-autoscaler
  #         spec:
  #           replicas: 1
  #           selector:
  #             matchLabels:
  #               app: cluster-autoscaler
  #           template:
  #             metadata:
  #               labels:
  #                 app: cluster-autoscaler
  #               annotations:
  #                 prometheus.io/scrape: 'true'
  #                 prometheus.io/port: '8085'
  #                 cluster-autoscaler.kubernetes.io/safe-to-evict: 'false'
  #             spec:
  #               priorityClassName: system-cluster-critical
  #               securityContext:
  #                 runAsNonRoot: true
  #                 runAsUser: 65534
  #                 fsGroup: 65534
  #               serviceAccountName: cluster-autoscaler
  #               containers:
  #                 - image: k8s.gcr.io/autoscaling/cluster-autoscaler:v{image_tag}
  #                   name: cluster-autoscaler
  #                   resources:
  #                     limits:
  #                       cpu: 100m
  #                       memory: 600Mi
  #                     requests:
  #                       cpu: 100m
  #                       memory: 600Mi
  #                   command:
  #                     - ./cluster-autoscaler
  #                     - --v=4
  #                     - --stderrthreshold=info
  #                     - --cloud-provider=aws
  #                     - --skip-nodes-with-local-storage=false
  #                     - --expander=least-waste
  #                     - --node-group-auto-discovery=asg:tag=k8s.io/cluster-autoscaler/enabled,k8s.io/cluster-autoscaler/${cluster_name}
  #                     - --balance-similar-node-groups
  #                     - --skip-nodes-with-system-pods=false
  #                   volumeMounts:
  #                     - name: ssl-certs
  #                       mountPath: /etc/ssl/certs/ca-certificates.crt #/etc/ssl/certs/ca-bundle.crt for Amazon Linux Worker Nodes
  #                       readOnly: true
  #                   imagePullPolicy: "Always"
  #               volumes:
  #                 - name: ssl-certs
  #                   hostPath:
  #                     path: "/etc/ssl/certs/ca-bundle.crt"
  #       - image_tag: !FindInMap [ClusterAutoscalerImageVersionMap, !Ref ClusterVersion, latest]
  #         cluster_name: !Ref Cluster

  # # ClusterAutoscalerOverProvisioningPod:
  #   Type: AWSQS::Kubernetes::Resource
  #   Condition: IsEnableClusterAutoscaler
  #   DependsOn: ClusterAutoscalerDeploymentImageUpdate
  #   Properties:
  #     ClusterName: !Ref Cluster
  #     Namespace: kube-system
  #     Manifest: |
  #       ---
  #       apiVersion: scheduling.k8s.io/v1beta1
  #       kind: PriorityClass
  #       metadata:
  #         name: overprovisioning
  #       value: -1
  #       globalDefault: false
  #       ---
  #       apiVersion: apps/v1
  #       kind: Deployment
  #       metadata:
  #         name: overprovisioning
  #         namespace: kube-system
  #       spec:
  #         replicas: 3
  #         selector:
  #           matchLabels:
  #             run: overprovisioning
  #         template:
  #           metadata:
  #             labels:
  #               run: overprovisioning
  #           spec:
  #             priorityClassName: overprovisioning
  #             containers:
  #             - name: reserve-resources
  #               image: k8s.gcr.io/pause
  #               resources:
  #                 requests:
  #                   cpu: 820m
  #                   memory: 2000Mi

Outputs:
  ClusterRoleArn:
    Value: !GetAtt ClusterRole.Arn
  AdditionalSecurityGroupId:
    Value: !GetAtt AdditionalSecurityGroup.GroupId
  ClusterArn:
    Value: !GetAtt Cluster.Arn
  ClusterSecurityGroupId:
    Value: !GetAtt Cluster.ClusterSecurityGroupId
  ClusterEndpoint:
    Value: !GetAtt Cluster.Endpoint
  ClusterOpenIdConnectIssuerUrl:
    Value: !GetAtt Cluster.OIDCIssuerURL
  OidcProviderArn:
    Value: !Ref OidcProvider
